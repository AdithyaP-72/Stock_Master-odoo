'use client'
import { useRef, useEffect, useCallback, useMemo } from 'react'
import { gsap } from 'gsap'
import { InertiaPlugin } from 'gsap/InertiaPlugin'
import './DotGrid.css'

gsap.registerPlugin(InertiaPlugin)

const throttle = (func: any, limit: number) => {
    let lastCall = 0
    return function (...args: any[]) {
        const now = performance.now()
        if (now - lastCall >= limit) {
            lastCall = now
            func.apply(null, args)
        }
    }
}

function hexToRgb(hex: string) {
    const m = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i)
    if (!m) return { r: 0, g: 0, b: 0 }
    return {
        r: parseInt(m[1], 16),
        g: parseInt(m[2], 16),
        b: parseInt(m[3], 16)
    }
}

export default function DotGrid({
    dotSize = 6,
    gap = 20,
    baseColor = '#0f172a',
    activeColor = '#22d3ee',
    proximity = 120,
    speedTrigger = 100,
    shockRadius = 200,
    shockStrength = 4,
    maxSpeed = 4000,
    resistance = 700,
    returnDuration = 1.2
}) {
    const wrapperRef = useRef<HTMLDivElement>(null)
    const canvasRef = useRef<HTMLCanvasElement>(null)
    const dotsRef = useRef<any[]>([])
    const pointerRef = useRef({
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        speed: 0,
        lastTime: 0,
        lastX: 0,
        lastY: 0
    })

    const baseRgb = useMemo(() => hexToRgb(baseColor), [baseColor])
    const activeRgb = useMemo(() => hexToRgb(activeColor), [activeColor])

    const circlePath = useMemo(() => {
        if (typeof window === 'undefined' || !window.Path2D) return null
        const p = new window.Path2D()
        p.arc(0, 0, dotSize / 2, 0, Math.PI * 2)
        return p
    }, [dotSize])

    const buildGrid = useCallback(() => {
        const wrap = wrapperRef.current
        const canvas = canvasRef.current
        if (!wrap || !canvas) return

        const { width, height } = wrap.getBoundingClientRect()
        const dpr = window.devicePixelRatio || 1

        canvas.width = width * dpr
        canvas.height = height * dpr
        canvas.style.width = `${width}px`
        canvas.style.height = `${height}px`

        const ctx = canvas.getContext('2d')
        if (ctx) ctx.scale(dpr, dpr)

        const cols = Math.floor((width + gap) / (dotSize + gap))
        const rows = Math.floor((height + gap) / (dotSize + gap))
        const cell = dotSize + gap

        const gridW = cell * cols - gap
        const gridH = cell * rows - gap

        const startX = (width - gridW) / 2 + dotSize / 2
        const startY = (height - gridH) / 2 + dotSize / 2

        const dots = []
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                dots.push({
                    cx: startX + x * cell,
                    cy: startY + y * cell,
                    xOffset: 0,
                    yOffset: 0,
                    _inertiaApplied: false
                })
            }
        }

        dotsRef.current = dots
    }, [dotSize, gap])

    useEffect(() => {
        if (!circlePath) return
        let rafId: number

        const draw = () => {
            const canvas = canvasRef.current
            if (!canvas) return

            const ctx = canvas.getContext('2d')
            if (!ctx) return

            ctx.clearRect(0, 0, canvas.width, canvas.height)

            const { x: px, y: py } = pointerRef.current

            dotsRef.current.forEach(dot => {
                const ox = dot.cx + dot.xOffset
                const oy = dot.cy + dot.yOffset

                const dx = dot.cx - px
                const dy = dot.cy - py
                const dist = Math.sqrt(dx * dx + dy * dy)

                let color = baseColor
                if (dist < proximity) {
                    const t = 1 - dist / proximity
                    const r = Math.round(baseRgb.r + (activeRgb.r - baseRgb.r) * t)
                    const g = Math.round(baseRgb.g + (activeRgb.g - baseRgb.g) * t)
                    const b = Math.round(baseRgb.b + (activeRgb.b - baseRgb.b) * t)
                    color = `rgb(${r},${g},${b})`
                }

                ctx.save()
                ctx.translate(ox, oy)
                ctx.fillStyle = color
                ctx.fill(circlePath)
                ctx.restore()
            })

            rafId = requestAnimationFrame(draw)
        }

        draw()
        return () => cancelAnimationFrame(rafId)
    }, [circlePath, baseColor, proximity, activeRgb, baseRgb])

    useEffect(() => {
        buildGrid()
        const ro = new ResizeObserver(buildGrid)
        if (wrapperRef.current) ro.observe(wrapperRef.current)

        return () => ro.disconnect()
    }, [buildGrid])

    useEffect(() => {
        const onMove = (e: MouseEvent) => {
            const rect = canvasRef.current?.getBoundingClientRect()
            if (!rect) return

            pointerRef.current.x = e.clientX - rect.left
            pointerRef.current.y = e.clientY - rect.top
        }

        const onClick = (e: MouseEvent) => {
            const rect = canvasRef.current?.getBoundingClientRect()
            if (!rect) return

            const cx = e.clientX - rect.left
            const cy = e.clientY - rect.top

            dotsRef.current.forEach(dot => {
                const dist = Math.hypot(dot.cx - cx, dot.cy - cy)
                if (dist < shockRadius && !dot._inertiaApplied) {
                    dot._inertiaApplied = true
                    gsap.to(dot, {
                        inertia: {
                            xOffset: (dot.cx - cx) * shockStrength,
                            yOffset: (dot.cy - cy) * shockStrength,
                            resistance
                        },
                        onComplete: () => {
                            gsap.to(dot, {
                                xOffset: 0,
                                yOffset: 0,
                                duration: returnDuration,
                                ease: 'elastic.out(1, 0.75)'
                            })
                            dot._inertiaApplied = false
                        }
                    })
                }
            })
        }

        const throttledMove = throttle(onMove, 20)

        window.addEventListener('mousemove', throttledMove)
        window.addEventListener('click', onClick)

        return () => {
            window.removeEventListener('mousemove', throttledMove)
            window.removeEventListener('click', onClick)
        }
    }, [shockRadius, shockStrength, resistance, returnDuration])

    return (
        <section className="dot-grid">
            <div className="dot-grid__wrap" ref={wrapperRef}>
                <canvas className="dot-grid__canvas" ref={canvasRef} />
            </div>
        </section>
    )
}
